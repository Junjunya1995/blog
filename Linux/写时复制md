#  写时复制(copy-on-write)
- 一般用于读多写少的情况，用于提高读取数据的效率
- 注意的是，读数据并不能保证实时性，因为读取时，读取的是旧数组的数据
- 缺点是：占用内存（每添加一次就需要复制一个数据）和数据一致性问题（不能保证实时数据）

## linux中的copy-on-write
当调用fork()系统调用创建一个子进程时，Linux并不会为子进程创建新的物理内存空间，而是公用父进程的物理内存。这是因为Linux的内核开发者觉得，调用者调用fork()系统调用后会立刻调用exec()系统调用执行新的程序，这样旧的物理内存内容就没有什么作用了（因为新的程序与旧的程序完全没有关联），所以为子进程复制父进程的物理内存内容是一件徒劳无功的事情。

所以Linux的做法就是：父子进程共用同一物理内存。把共用的物理内存设置为只读，因为读操作不会改变内存的内容，所以对于父子进程都是允许的。而当父子进程其中一个进行写操作时，因为内存被设置为只读，所以CPU会触发 “page fault” 的错误，从而调用内核的do_page_fault()函数。而do_page_fault()函数又会调用do_wp_page()函数去进行复制父进程内存的内容。


## PHP变量的copy-on-write
```

<?php   //例一
    $foo = 1;
    $bar = $foo;
    echo $foo + $bar;  // 输出2
    echo $foo += $bar; // 输出2
```
这段代码从内存分析 `$foo = 1;`时，分配一块内存给$foo变量，里面存储一个，然后因为`$bar = $foo;`, 此时$bar 完全等于$foo, 两者指向同一块内存，可以省去分配内存和管理内存的开销。
